let (:extractedAppName, :extractedEpName, :annotations, :tags, :annoRel, :tagRel,
     :load, :polish, :normalize, :newNormalize, ...) = //{./sysl};

let _model = load('out/model.pb');

let _app = (
    appName: 'App',
    attrs: {
        'foo': (s: 'bar'),
        'patterns': (a: (elt: [(s: 'db')])),
    },
);

(
    extractedAppName: (
        empty: //test.assert.equal(extractedAppName({}),{}),
        string: //test.assert.equal(extractedAppName('foo'),'foo'),
        namedItem: //test.assert.equal(extractedAppName((@:0, @item:(name: (part: 'foo')))),'foo'),
        app: //test.assert.equal(extractedAppName((name: (part: ['foo']))),['foo']),
    ),
    extractedEpName: (
        empty: extractedEpName({}) = {},
        string: extractedEpName('foo') = 'foo',
        named: extractedEpName((name: 'foo')) = 'foo',
        namedItem: extractedEpName((@:0, @item:(name: 'foo'))) = 'foo',
    ),
    annotations: (
        empty: annotations(()) = {},
        string: annotations((attrs: {'foo': (s: 'bar')})) = {'foo': 'bar'},
        array: annotations((attrs: {'foo': (a: (elt: [(s: 'bar')]))})) = {'foo': ['bar']},
        arrayOfArrays: 
            let result = annotations(
                (attrs: 
                    {'foo': 
                        (a: 
                            (elt: 
                                (a: 
                                    (elt: [(s: 'bar')])
                                )
                            )
                        )
                    }
                    
                )
            );
            let expected = {'foo': ['bar']};
            //test.assert.equal(expected, result),
    ),
    tags: (
        empty: tags(()) = {},
        array: tags((attrs: {'patterns': (a: (elt: [(s: 'bar')]))})) = {'bar'},
    ),
    annoRel: (
        "empty": //test.assert.equal({},annoRel('app', {})),
        "single": 
            let expected = {(appName: 'App', appAnnoName: 'foo', appAnnoValue: 'bar')};
            let result = annoRel('app', {(appName: 'App', app: _app)});
            //test.assert.equal(expected, result),
            
    ),
    tagRel: (
        "empty": tagRel('app', {}) = {},
        "single": tagRel('app', {(appName: 'App', app: _app)}) =
             {(appName: 'App', appTag: 'db')},
    ),

    polish: (
        idempotent: 
            let expected = polish(_model);
            let result = polish(polish(_model));
            //test.assert.equal(expected, result),
    ),
    normalize: (
        model: 
            let result = normalize(_model);
            //test.assert.unequal((), result),
    ),
    newNormalize: (
        model: 
            let result = newNormalize(_model);
            //test.assert.unequal((), result),
        # all:
        #     let _all = load('out/all.pb');
        #     let expected = //{./test_all_sysl_normalized};
        #     let result = newNormalize(_all);
        #     //test.assert.equal(expected, result),
    ),
)
